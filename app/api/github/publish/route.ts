import { NextResponse } from 'next/server';
import { Octokit } from 'octokit';
import { GITHUB_CONFIG } from '../../../../lib/config.mjs';
import { auth } from '../../../../auth';

/**
 * API to publish tech stack updates to GitHub.
 * Follows the workflow:
 * 1. Check if 'tech-stack-update-{version}' branch exists.
 * 2. If not, create it from 'release-12'.
 * 3. Update/Create the versioned JSON file in data/tech-stack-data/.
 */
export async function POST(req: Request) {
  try {
    // Get the authenticated user's session
    const session = await auth();
    const userEmail = session?.user?.email || 'unknown-user';
    
    const { version, data, commitMessage } = await req.json();

    if (!version || !data) {
      return NextResponse.json({ error: 'Version and data are required' }, { status: 400 });
    }

    const { OWNER, REPO, BRANCH, DATA_PATH } = GITHUB_CONFIG;
    const GITHUB_TOKEN = process.env.GITHUB_TOKEN;

    if (!GITHUB_TOKEN) {
      throw new Error('GITHUB_TOKEN not configured in environment');
    }

    const octokit = new Octokit({ auth: GITHUB_TOKEN });

    // Sanitize version for branch name (remove dots if preferred, or keep them)
    // GitHub branches usually don't mind dots, but let's be safe.
    const targetBranch = BRANCH; // Directly push to release-12 as requested
    const filePath = `${DATA_PATH}/${version}.json`;

    console.log(`üöÄ Publishing version ${version} directly to branch ${targetBranch}...`);

    // Removed branch creation logic to push directly to the main release branch.

    // 3. Get existing file SHA (if any) to perform update
    let fileSha: string | undefined;
    try {
      const { data: existingFile } = await octokit.rest.repos.getContent({
        owner: OWNER,
        repo: REPO,
        path: filePath,
        ref: targetBranch,
      });
      
      if (!Array.isArray(existingFile)) {
        fileSha = existingFile.sha;
        console.log(`Updating existing file: ${filePath} (sha: ${fileSha})`);
      }
    } catch (e: any) {
      if (e.status === 404) {
         console.log(`Creating new file: ${filePath}`);
      } else {
        throw e;
      }
    }

    // 4. Push changes
    const content = JSON.stringify(data, null, 2);
    const timestamp = new Date().toISOString().replace('T', ' ').split('.')[0];
    const autogeneratedMessage = `docs(tech-stack): update ${version} definitions via DocsFlow Editor\n\n- Updated on: ${timestamp}\n- Automated commit made using docs-flow by ${userEmail}`;

    const { data: commitResult } = await octokit.rest.repos.createOrUpdateFileContents({
      owner: OWNER,
      repo: REPO,
      path: filePath,
      message: commitMessage || autogeneratedMessage,
      content: Buffer.from(content).toString('base64'),
      branch: targetBranch,
      sha: fileSha,
    });

    console.log(`‚úÖ Push successful. Commit: ${commitResult.commit.sha}`);

    // --- PR Automation ---
    const { UPSTREAM_OWNER, UPSTREAM_REPO, UPSTREAM_BRANCH } = GITHUB_CONFIG;
    let prUrl = null;
    let prStatus = 'already_exists';

    try {
      // 1. Check if PR already exists
      const { data: existingPrs } = await octokit.rest.pulls.list({
        owner: UPSTREAM_OWNER,
        repo: UPSTREAM_REPO,
        head: `${OWNER}:${targetBranch}`,
        base: UPSTREAM_BRANCH,
        state: 'open',
      });

      if (existingPrs.length === 0) {
        console.log(`üîÄ No open PR found. Creating new PR from ${OWNER}:${targetBranch} to ${UPSTREAM_OWNER}:${UPSTREAM_BRANCH}...`);
        
        const { data: newPr } = await octokit.rest.pulls.create({
          owner: UPSTREAM_OWNER,
          repo: UPSTREAM_REPO,
          title: `docs(tech-stack): automated update for ${version}`,
          head: `${OWNER}:${targetBranch}`,
          base: UPSTREAM_BRANCH,
          body: `## Tech Stack Update: ${version}\n\n- Automated update made using **DocsFlow Editor**\n- Triggered by: ${userEmail}\n- Latest Commit: ${commitResult.commit.sha}\n\nThis PR was automatically generated/updated by the DocsFlow application.`,
          maintainer_can_modify: true,
        });

        prUrl = newPr.html_url;
        prStatus = 'created';
        console.log(`‚úÖ PR created: ${prUrl}`);
      } else {
        prUrl = existingPrs[0].html_url;
        console.log(`‚ÑπÔ∏è Existing PR found: ${prUrl}. Push has already updated it.`);
      }
    } catch (prError: any) {
      console.error('‚ö†Ô∏è PR Automation Error:', prError.message);
      // We don't fail the whole request if PR fails, as the push was successful
      prStatus = 'error';
    }

    return NextResponse.json({
      success: true,
      branch: targetBranch,
      sha: commitResult.commit.sha,
      url: `${GITHUB_CONFIG.BASE_URL}/blob/${targetBranch}/${filePath}`,
      pr: {
        url: prUrl,
        status: prStatus
      }
    });

  } catch (error: any) {
    console.error('‚ùå GitHub Publish API Error:', error);
    return NextResponse.json({ 
      error: error.message || 'Failed to publish to GitHub',
      details: error.response?.data
    }, { status: 500 });
  }
}
